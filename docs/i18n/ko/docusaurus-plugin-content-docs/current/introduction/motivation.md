---
title: 동기
---

호환성과 단순함 때문에 외부의 전역적인 상태보다는 React의 내장된 상태 관리 기능을 사용하는 것이 좋다. 그러나 React는 다음과 같은 한계가 있다.

- 컴포넌트의 상태는 공통된 조상으로 넣어야 공유할 수 있지만, 이것은 거대한 트리가 포함되어 다시 렌더링을 해야한다.
- Context는 단일 값만 저장할 수 있으며 자체적인 소비자가 있는 정의되지않은 집합 값은 저장할 수 없다.
- 이 두가지가 트리의 윗부분 (state가 존재하는 곳)부터 트리의 잎 (state가 사용되는 곳)까지의 코드 분할을 어렵게한다.

우리는 API와 의미와 행동을 가능한 React답게 유지하면서 이것을 개선하고자 한다.

Recoil은 직교하지만 본질적인 방향 그래프를 정의하고 React 트리에 붙인다. 
다음과 같은 접근 방식을 통해 상태 변화는 이 그래프의 뿌리(atoms라고 부르는)에서 순수함수(selectors라고 부르는 것)를 거쳐 컴포넌트로 흐른다.

- 우리는 공유되는 상태가 React 내부 상태와 동일한 간단한 get/set 인터페이스를 갖는 boilerplate-free API를 얻는다.(필요한 경우 reducers 등으로 캡슐화할 수 있다.)
- 우리는 Concurrent 모드와 추후 사용가능한 다른 새로 제공되는 React의 기능과의 호환 가능성을 갖는다.
- 상태 정의는 증분적이고 분산되어 있어 코드 분할이 가능하다.
- 상태를 사용하는 컴포넌트를 수정하지 않고 파생된 데이터로 상태를 대체할 수 있다.
- 파생된 데이터는 그것을 사용하는 구성 요소를 수정하지 않고 동기식 데이터와 비동기식 사이에서 이동할 수 있다.
- 우리는 탐색을 일급 개념으로 취급할 수 있고 심지어 링크에서 상태 전환을 인코딩할 수도 있다.
- 역호환성 방식으로 전체 애플리케이션 상태를 유지하기가 쉬우므로 지속된 상태가 애플리케이션 변경에서 살아남을 수 있다.
